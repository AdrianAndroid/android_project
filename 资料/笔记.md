# 资料
[Android窗口管理5　理解ViewRootImpl](https://blog.csdn.net/liuwg1226/article/details/113100302)

# View 设置 ViewParent
```
    @UnsupportedAppUsage
    void assignParent(ViewParent parent) {
        if (mParent == null) {
            mParent = parent;
        } else if (parent == null) {
            mParent = null;
        } else {
            throw new RuntimeException("view " + this + " being added, but"
                    + " it already has a parent");
        }
    }
```

# requestLayout & invalidate & postInvalidate
相同点：
    * 都是从子 View -》父View -》 DecorView -》 ViewRootImpl从子到父层层调用
    * 都会导致View树重绘，最终会调用到ViewRootImpl#scheduleTraversals
不同点：
    * requestLayout 在UI线程调用
    * invalidate 在UI线程调用。当View树可见时，会调用到onDraw
    * postInvalidate 可以在非UI线程调用。逻辑和invalidate类似，不同点是postInvalidate通过发消息方式，使invalidate操作在消息队列里有序执行

# 常见问题
## 1。 什么时候获取View的测量高度
```
private void performTraversals() {
    ......
    performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);
    ......
    performLayout(lp, mWidth, mHeight);
    ......
    if (triggerGlobalLayoutListener) {
        mAttachInfo.mRecomputeGlobalAttributes = false;
        mAttachInfo.mTreeObserver.dispatchOnGlobalLayout();
    }
    ......
    performDraw();
    ......
}
```
根据ViewRootImpl#scheduleTraversals的调用逻辑。
dispatchOnGlobalLayout在performMeasure-performLayout之后调用，通过该回调可以获取到测量的高度
App层可以通过注册OnGlobalLayoutListener方式获取
```
view.getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
    @Override
    public void onGlobalLayout() {
		// view.getMeasuredWidth()/view.getMeasuredHeight()
		......
    }
});
```


## 2。 在子线程中可以更新UI吗
在Activity#onResume之前，可以在子线程更新UI。
checkThread()线程检查是在ViewRootImpl的方法中进行的（如invlidate和requestLayout）
而通过溯源代码，ViewRootImpl是在ActivityThread#handResumeActivity创建的。
在Activity#onResume之前ViewRootImpl还没创建，所以也不会检查线程和绘制UI。
```
@Override
public void requestLayout() {
    if (!mHandlingLayoutInLayoutRequest) {
        checkThread();
        mLayoutRequested = true;
        scheduleTraversals();
    }
}

@Override
public ViewParent invalidateChildInParent(int[] location, Rect dirty) {
    checkThread();
    ......
}

void checkThread() {
    if (mThread != Thread.currentThread()) {
        throw new CalledFromWrongThreadException(
                "Only the original thread that created a" +
                "view hierarchy can touch its views.");
    }
}

```